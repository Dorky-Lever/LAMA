#!/usr/bin/env python

import logging
import SimpleITK as sitk
import sys
from os.path import splitext, basename, join
import os
import common
import yaml
import numpy as np
from utilities.extract_region_from_sices import write_roi_from_image_stack
import logging
import math


def pad_volumes(volpaths, max_dims, outdir, filetype='nrrd'):
    """
    Pad volumes, masks, labels. Output files will have same name as original, but be in a new output folder

    Parameters
    ----------
    volpaths: list
        list of paths to volumes
    maxdims: list
        dimensions to pad to (z, Y, x)
    outdir: str
        path to output dir
    """
    logging.info('Padding to {} - {} volumes/masks:'.format(str(max_dims), str(len(volpaths))))

    for path in volpaths:

        vol = sitk.ReadImage(path)
        vol_dims = vol.GetSize()

        # The voxel differences between the vol dims and the max dims
        diffs = [m - v for m, v in zip(max_dims, vol_dims)]

        # How many pixels to add to the upper bounds of each dimension, divide by two and round up to nearest int
        upper_extend = [d / 2 for d in diffs]

        # In case of differnces that cannot be /2. Get the remainder to add to the lower bound
        remainders = [d % 2 for d in diffs]

        # Add the remainders to the upper bound extension to get the lower bound extension
        lower_extend = [u + r for u, r in zip(upper_extend, remainders)]

        # if any values are negative, stop. We need all volumes to be the same size
        for ex_val in zip(lower_extend, upper_extend):
            if ex_val[0] < 0 or ex_val[1] < 0:
                sys.exit("can't pad images. {} is larger than the specified volume size"
                         "Check the 'pad_dims' in the config file".format(path))

        # Pad the volume. New pixels set to zero
        padded_vol = sitk.ConstantPad(vol, upper_extend, lower_extend, 0)
        padded_vol.SetOrigin((0, 0, 0))
        padded_vol.SetSpacing((1, 1, 1))

        input_basename = splitext(basename(path))[0]
        padded_outname = join(outdir, '{}.{}'.format(input_basename, filetype))
        sitk.WriteImage(padded_vol, padded_outname, True)
        print input_basename, upper_extend, lower_extend
    return input_basename, upper_extend, lower_extend


def unpad_roi(pad_info, inverted_rois, voxel_size, outdir):
    """
    Given a dir with inverted rois in VTK format, return a list of ROIs that have been corrected for the padding that
    occured just before registration
    Parameters
    ----------
    pad_info: str
        path to pad_info file
        formated like 'volume id no extension, upper padding amounts, lower padding amounts
        eg:
            20160406_ATP1A2_E14.5_2.3g_WT_ND_scaled_4.7297_pixel_13.9999,[44, 31, 70],[44, 31, 70]
            20150305_HHIPL1_E14.5_19.1h_WT_XY_REC_scaled_4.6878_pixel_14.0,[31, 5, 40],[32, 5, 40]
    inverted_rois: str
        path to dir containing inverted rois in VTK format

    Returns
    -------
    """

    inputs = '/home/neil/sig/LAMA_results/E14.5/120716_E14.5_14um_test_set/output/padded_inputs'

    if __name__ == '__main__':
        logpath = join(outdir, 'Extract_roi.log')
        common.init_logging(logpath)

    #Load the pad_info. This was generated by LAMA while padding before the registration started
    pad_info_dict = {}
    with open(pad_info, 'r') as pf:
        config = yaml.load(pf)
        full_res_root_dir = config['root_folder']
        full_res_subfolder_name = config['full_res_subfolder']
        log_file_pattern = config['log_file_endswith']
        voxel_size_entry = config['voxel_size_entry']
        data = config['data']

    # Extract the amount of padding for each volume
    for vol_id, vol_info in data.iteritems():
        pad = vol_info['pad']
        pad_info_dict[vol_id] = pad

    unpadded_results = {}
    dirs = os.listdir(inverted_rois)
    for dir_ in dirs:
        folder = join(inverted_rois, dir_)
        if os.path.isdir(folder):
            vtk_file = join(folder, [x for x in os.listdir(folder) if x.endswith('.vtk')][0])
            roi_starts, roi_ends = extract_roi_from_vtk(vtk_file)
            start_pad, end_pad = pad_info_dict[basename(folder)]

            unpadded_roi_start = np.array(roi_starts) - np.array(start_pad)
            unpadded_roi_end = np.array(roi_ends) - np.array(start_pad)
            #unpadded_results[basename(folder)] = (unpadded_roi_start, unpadded_roi_end)

            # testing: use padded inputs and padded rois
            unpadded_results[basename(folder)] = (roi_starts, roi_ends)

    # Now scale back up to size of full res images
    for vol_id, vol_info in data.iteritems():
        full_res_name = vol_info['full_res_folder']
        full_res_folder = join(full_res_root_dir, full_res_name, full_res_subfolder_name)
        try:
            log = [join(full_res_folder, x) for x in os.listdir(full_res_folder) if x.endswith(log_file_pattern)][0]
        except OSError:
            print vol_id, 'is changed on the server'
            continue
        except IndexError:
            print "can't find log file for", vol_id
            continue
        with open(log, 'r') as lf:
            original_voxel_size = None
            for line in lf:
                if line.startswith(voxel_size_entry):
                    original_voxel_size = float(line.split('=')[1].strip())
                    print original_voxel_size
                    break
        if not original_voxel_size:
            print "Could not acquire voxel size for", vol_id
            continue

        img_path = join(inputs, vol_id)
        try:
            img = sitk.ReadImage(img_path + '.nrrd')
        except RuntimeError:
            'skipping must be tif'
            continue
        arr = sitk.GetArrayFromImage(img)
        s, e = unpadded_results[vol_id]
        x1, y1, z1 = s
        x2, y2, z2 = e
        arr_roi = arr[z1:z2, y1:y2, x1:x2]
        img_out = sitk.GetImageFromArray(arr_roi)
        outpath = join(outdir, vol_id + '_roi.nrrd')
        sitk.WriteImage(img_out, outpath)

        # As a test extract the roi from the unpadded scaled images



        # scaling_factor = voxel_size / original_voxel_size
        # roi_starts, roi_ends = unpadded_results[vol_id]
        # new_starts = np.array(roi_starts) * scaling_factor
        # new_ends = np.array(roi_ends) * scaling_factor
        # roi_out_path = join(outdir, vol_id + 'roi.nrrd')
        # write_roi_from_image_stack(full_res_folder, roi_out_path, new_starts, new_ends)


def extract_roi_from_vtk(vtk_file):
    with open(vtk_file, 'r') as fh:
        for line in fh:
            if line.lower().startswith('points'):
                roi_starts = [round(float(x)) for x in fh.next().strip().split(' ')]
                roi_ends = [round(float(x)) for x in fh.next().strip().split(' ')]
                return roi_starts, roi_ends
    return None

if __name__ == '__main__':

    import argparse

    if sys.argv[1] == 'pad_vol':

        parser = argparse.ArgumentParser("padd a folder of images")
        parser.add_argument('-d', '--dir', dest='indir', help='directory with images', required=True)
        parser.add_argument('-o', '--out_file', dest='outdir', help='where to put padded images', required=True)
        parser.add_argument('-m', '--max_dims', dest='max_dims', nargs=3, type=int, help='xyz to padd to (with spaces)',
                            required=True)
        args, _ = parser.parse_known_args()

        input_imgs = common.GetFilePaths(args.indir)
        pad_volumes(input_imgs, args.max_dims, args.outdir)

    elif sys.argv[1] == 'unpad_roi':
        parser = argparse.ArgumentParser("unpad a folder of ROIs in vtk format")
        parser.add_argument('-i', '--pad_info', dest='pad_info', help='', required=True)
        parser.add_argument('-r', '--roi_dir', dest='roi_dir', help='', required=True)
        parser.add_argument('-v', '--voxel_size', dest='voxel_size', help='voxel size of the scaled images',
                            required=True, type=float)
        parser.add_argument('-o', '--outdir', dest='out_dir', help='', required=True)

        args, _ = parser.parse_known_args()
        unpadded_rois = unpad_roi(args.pad_info, args.roi_dir, args.voxel_size, args.out_dir)
        # for name, rois in unpadded_rois.iteritems():
        #     print name, rois[0], rois[1]
