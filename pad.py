#!/usr/bin/env python

import logging
import SimpleITK as sitk
import sys
from os.path import splitext, basename, join
import os
import common
import csv
import numpy as np
import ast


def pad_volumes(volpaths, max_dims, outdir, filetype='nrrd'):
    """
    Pad volumes, masks, labels. Output files will have same name as original, but be in a new output folder

    Parameters
    ----------
    volpaths: list
        list of paths to volumes
    maxdims: list
        dimensions to pad to (z, Y, x)
    outdir: str
        path to output dir
    """
    logging.info('Padding to {} - {} volumes/masks:'.format(str(max_dims), str(len(volpaths))))

    for path in volpaths:

        vol = sitk.ReadImage(path)
        vol_dims = vol.GetSize()

        # The voxel differences between the vol dims and the max dims
        diffs = [m - v for m, v in zip(max_dims, vol_dims)]

        # How many pixels to add to the upper bounds of each dimension, divide by two and round up to nearest int
        upper_extend = [d / 2 for d in diffs]

        # In case of differnces that cannot be /2. Get the remainder to add to the lower bound
        remainders = [d % 2 for d in diffs]

        # Add the remainders to the upper bound extension to get the lower bound extension
        lower_extend = [u + r for u, r in zip(upper_extend, remainders)]

        # if any values are negative, stop. We need all volumes to be the same size
        for ex_val in zip(lower_extend, upper_extend):
            if ex_val[0] < 0 or ex_val[1] < 0:
                sys.exit("can't pad images. {} is larger than the specified volume size"
                         "Check the 'pad_dims' in the config file".format(path))

        # Pad the volume. New pixels set to zero
        padded_vol = sitk.ConstantPad(vol, upper_extend, lower_extend, 0)
        padded_vol.SetOrigin((0, 0, 0))
        padded_vol.SetSpacing((1, 1, 1))

        input_basename = splitext(basename(path))[0]
        padded_outname = join(outdir, '{}.{}'.format(input_basename, filetype))
        sitk.WriteImage(padded_vol, padded_outname, True)
        print input_basename, upper_extend, lower_extend
    return input_basename, upper_extend, lower_extend


def unpad_roi(pad_info, inverted_rois):
    """
    Given a dir with inverted rois in VTK format, return a list of ROIs that have been corrected for the padding that
    occured just before registration
    Parameters
    ----------
    pad_info: str
        path to pad_info file
        formated like 'volume id no extension, upper padding amounts, lower padding amounts
        eg:
            20160406_ATP1A2_E14.5_2.3g_WT_ND_scaled_4.7297_pixel_13.9999,[44, 31, 70],[44, 31, 70]
            20150305_HHIPL1_E14.5_19.1h_WT_XY_REC_scaled_4.6878_pixel_14.0,[31, 5, 40],[32, 5, 40]
    inverted_rois: str
        path to dir containing inverted rois in VTK format

    Returns
    -------
    """

    #Load the pad_info. This was generated by LAMA while paddign before the registration started
    pad_info_dict = {}
    with open(pad_info, 'r') as pf:
        csvreader = csv.reader(pf)
        for row in csvreader:
            s = ast.literal_eval(row[1])
            e = ast.literal_eval(row[2])
            pad_info_dict[row[0]] = (s, e)

    results = {}
    dirs = os.listdir(inverted_rois)
    for dir_ in dirs:
        folder = join(inverted_rois, dir_)
        if os.path.isdir(folder):
            vtk_file = join(folder, [x for x in os.listdir(folder) if x.endswith('.vtk')][0])
            roi_starts, roi_ends = extract_roi(vtk_file)
            start_pad, end_pad = pad_info_dict[basename(folder)]

            unpadded_roi_start = np.array(roi_starts) - np.array(start_pad)
            unpadded_roi_end = np.array(roi_ends) - np.array(start_pad)
            results[basename(folder)] = (unpadded_roi_start, unpadded_roi_end)
    return results


def extract_roi(vtk_file):
    with open(vtk_file, 'r') as fh:
        for line in fh:
            if line.lower().startswith('points'):
                roi_starts = [float(x) for x in fh.next().strip().split(' ')]
                roi_ends = [float(x) for x in fh.next().strip().split(' ')]
                return roi_starts, roi_ends
    return None

if __name__ == '__main__':

    import argparse

    if sys.argv[1] == 'pad_vol':

        parser = argparse.ArgumentParser("padd a folder of images")
        parser.add_argument('-d', '--dir', dest='indir', help='directory with images', required=True)
        parser.add_argument('-o', '--out_file', dest='outdir', help='where to put padded images', required=True)
        parser.add_argument('-m', '--max_dims', dest='max_dims', nargs=3, type=int, help='xyz to padd to (with spaces)',
                            required=True)
        args, _ = parser.parse_known_args()

        input_imgs = common.GetFilePaths(args.indir)
        pad_volumes(input_imgs, args.max_dims, args.outdir)

    elif sys.argv[1] == 'unpad_roi':
        parser = argparse.ArgumentParser("unpad a folder of ROIs in vtk format")
        parser.add_argument('-i', '--pad_info', dest='pad_info', help='', required=True)
        parser.add_argument('-r', '--roi_dir', dest='roi_dir', help='', required=True)

        args, _ = parser.parse_known_args()
        unpadded_rois = unpad_roi(args.pad_info, args.roi_dir)
        for name, rois in unpadded_rois.iteritems():
            print name, rois[0], rois[1]
